/**
 * G-code Generator for CNC Machines
 * Generates CNC machine code for cutting operations
 */

// ==================== INTERFACES ====================

/** G-code generation options */
export interface IGcodeOptions {
    /** Feed rate for cutting (mm/min) */
    feedRate: number;
    /** Rapid move rate (mm/min) */
    rapidRate: number;
    /** Spindle speed (RPM) */
    spindleSpeed: number;
    /** Cutting depth (mm) */
    cuttingDepth: number;
    /** Safe Z height (mm) */
    safeZ: number;
    /** Work Z height (mm) - cutting position */
    workZ: number;
    /** Tool diameter (mm) */
    toolDiameter: number;
    /** Use relative coordinates */
    relativeCoords?: boolean;
    /** Add comments to G-code */
    includeComments?: boolean;
    /** Machine type for specific syntax */
    machineType?: 'GENERIC' | 'FANUC' | 'HAAS' | 'MACH3';
}

/** Cutting path for a single piece */
export interface ICuttingPath {
    pieceId: string;
    pieceCode?: string;
    /** Start point */
    startX: number;
    startY: number;
    /** Width and height of rectangle */
    width: number;
    height: number;
    /** Rotation angle in degrees */
    rotation?: number;
}

/** Sheet with cutting paths */
export interface ICuttingSheet {
    sheetId: string;
    sheetCode: string;
    sheetWidth: number;
    sheetHeight: number;
    paths: ICuttingPath[];
}

/** G-code output */
export interface IGcodeOutput {
    content: string;
    lineCount: number;
    estimatedTime: number; // minutes
    filename: string;
}

// ==================== DEFAULT OPTIONS ====================

const DEFAULT_OPTIONS: IGcodeOptions = {
    feedRate: 1000,
    rapidRate: 3000,
    spindleSpeed: 12000,
    cuttingDepth: 10,
    safeZ: 5,
    workZ: -10,
    toolDiameter: 3.175, // 1/8 inch
    relativeCoords: false,
    includeComments: true,
    machineType: 'GENERIC'
};

// ==================== G-CODE GENERATOR ====================

export class GcodeGenerator {
    private options: IGcodeOptions;
    private lines: string[] = [];
    private totalDistance = 0;

    constructor(options: Partial<IGcodeOptions> = {}) {
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }

    /**
     * Generate G-code for a cutting sheet
     */
    generateForSheet(sheet: ICuttingSheet): IGcodeOutput {
        this.lines = [];
        this.totalDistance = 0;

        // Header
        this.addHeader(sheet);

        // Initialize machine
        this.addInitialization();

        // Process each cutting path
        for (let i = 0; i < sheet.paths.length; i++) {
            const path = sheet.paths[i];
            this.addCuttingPath(path, i + 1);
        }

        // Footer
        this.addFooter();

        const content = this.lines.join('\n');
        const estimatedTime = this.calculateEstimatedTime();

        return {
            content,
            lineCount: this.lines.length,
            estimatedTime,
            filename: `${sheet.sheetCode}_cutting.nc`
        };
    }

    /**
     * Generate G-code for multiple sheets
     */
    generateForMultipleSheets(sheets: ICuttingSheet[]): IGcodeOutput[] {
        return sheets.map((sheet) => this.generateForSheet(sheet));
    }

    private addHeader(sheet: ICuttingSheet): void {
        if (this.options.includeComments) {
            this.lines.push(`; ========================================`);
            this.lines.push(`; G-code generated by Nestra`);
            this.lines.push(`; Sheet: ${sheet.sheetCode}`);
            this.lines.push(`; Dimensions: ${sheet.sheetWidth} x ${sheet.sheetHeight} mm`);
            this.lines.push(`; Pieces: ${sheet.paths.length}`);
            this.lines.push(`; Date: ${new Date().toISOString()}`);
            this.lines.push(`; ========================================`);
            this.lines.push('');
        }

        // Program number (if supported)
        if (this.options.machineType === 'FANUC' || this.options.machineType === 'HAAS') {
            this.lines.push('O0001');
        }
    }

    private addInitialization(): void {
        // Set units to mm
        this.lines.push('G21 ; Units: millimeters');

        // Absolute/relative positioning
        if (this.options.relativeCoords) {
            this.lines.push('G91 ; Relative positioning');
        } else {
            this.lines.push('G90 ; Absolute positioning');
        }

        // Select XY plane
        this.lines.push('G17 ; XY plane selection');

        // Cancel cutter compensation
        this.lines.push('G40 ; Cancel cutter compensation');

        // Move to safe position
        this.lines.push(`G0 Z${this.options.safeZ} ; Move to safe Z`);
        this.lines.push('G0 X0 Y0 ; Move to origin');

        // Start spindle
        this.lines.push(`M3 S${this.options.spindleSpeed} ; Spindle ON CW`);

        // Dwell for spindle to reach speed
        this.lines.push('G4 P2 ; Dwell 2 seconds');
        this.lines.push('');
    }

    private addCuttingPath(path: ICuttingPath, index: number): void {
        const { startX, startY, width, height } = path;
        const toolRadius = this.options.toolDiameter / 2;

        // Compensate for tool radius (outside cutting)
        const x1 = startX - toolRadius;
        const y1 = startY - toolRadius;
        const x2 = startX + width + toolRadius;
        const y2 = startY + height + toolRadius;

        if (this.options.includeComments) {
            this.lines.push(`; --- Piece ${index}: ${path.pieceCode ?? path.pieceId} ---`);
            this.lines.push(`; Dimensions: ${width} x ${height} mm`);
        }

        // Rapid move to start position (at safe Z)
        this.lines.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)} ; Rapid to start`);
        this.totalDistance += Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2));

        // Plunge to cutting depth
        this.lines.push(`G0 Z${this.options.safeZ} ; Safe Z`);
        this.lines.push(`G1 Z${this.options.workZ} F${this.options.feedRate / 2} ; Plunge`);

        // Cut rectangle (clockwise)
        // Bottom edge (left to right)
        this.lines.push(`G1 X${x2.toFixed(3)} Y${y1.toFixed(3)} F${this.options.feedRate}`);
        this.totalDistance += width + this.options.toolDiameter;

        // Right edge (bottom to top)
        this.lines.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)}`);
        this.totalDistance += height + this.options.toolDiameter;

        // Top edge (right to left)
        this.lines.push(`G1 X${x1.toFixed(3)} Y${y2.toFixed(3)}`);
        this.totalDistance += width + this.options.toolDiameter;

        // Left edge (top to bottom, close path)
        this.lines.push(`G1 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);
        this.totalDistance += height + this.options.toolDiameter;

        // Retract to safe Z
        this.lines.push(`G0 Z${this.options.safeZ} ; Retract`);
        this.lines.push('');
    }

    private addFooter(): void {
        // Stop spindle
        this.lines.push('M5 ; Spindle OFF');

        // Return to origin
        this.lines.push('G0 Z' + this.options.safeZ + ' ; Safe Z');
        this.lines.push('G0 X0 Y0 ; Return to origin');

        // Program end
        if (this.options.machineType === 'FANUC' || this.options.machineType === 'HAAS') {
            this.lines.push('M30 ; End program, rewind');
        } else {
            this.lines.push('M2 ; End program');
        }

        if (this.options.includeComments) {
            this.lines.push('');
            this.lines.push(`; Total cutting distance: ${this.totalDistance.toFixed(1)} mm`);
        }
    }

    private calculateEstimatedTime(): number {
        // Rough estimate: cutting distance / feed rate + rapid moves
        const cuttingTime = this.totalDistance / this.options.feedRate;
        const rapidTime = (this.totalDistance * 0.2) / this.options.rapidRate; // Estimate 20% rapid
        return cuttingTime + rapidTime;
    }
}

// ==================== HELPER FUNCTIONS ====================

/**
 * Generate G-code string for a sheet
 */
export function generateGcode(sheet: ICuttingSheet, options?: Partial<IGcodeOptions>): IGcodeOutput {
    const generator = new GcodeGenerator(options);
    return generator.generateForSheet(sheet);
}

/**
 * Generate G-code for multiple sheets
 */
export function generateMultipleGcode(sheets: ICuttingSheet[], options?: Partial<IGcodeOptions>): IGcodeOutput[] {
    const generator = new GcodeGenerator(options);
    return generator.generateForMultipleSheets(sheets);
}
