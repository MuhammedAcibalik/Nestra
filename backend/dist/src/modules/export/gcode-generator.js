"use strict";
/**
 * G-code Generator for CNC Machines
 * Generates CNC machine code for cutting operations
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GcodeGenerator = void 0;
exports.generateGcode = generateGcode;
exports.generateMultipleGcode = generateMultipleGcode;
// ==================== DEFAULT OPTIONS ====================
const DEFAULT_OPTIONS = {
    feedRate: 1000,
    rapidRate: 3000,
    spindleSpeed: 12000,
    cuttingDepth: 10,
    safeZ: 5,
    workZ: -10,
    toolDiameter: 3.175, // 1/8 inch
    relativeCoords: false,
    includeComments: true,
    machineType: 'GENERIC'
};
// ==================== G-CODE GENERATOR ====================
class GcodeGenerator {
    options;
    lines = [];
    totalDistance = 0;
    constructor(options = {}) {
        this.options = { ...DEFAULT_OPTIONS, ...options };
    }
    /**
     * Generate G-code for a cutting sheet
     */
    generateForSheet(sheet) {
        this.lines = [];
        this.totalDistance = 0;
        // Header
        this.addHeader(sheet);
        // Initialize machine
        this.addInitialization();
        // Process each cutting path
        for (let i = 0; i < sheet.paths.length; i++) {
            const path = sheet.paths[i];
            this.addCuttingPath(path, i + 1);
        }
        // Footer
        this.addFooter();
        const content = this.lines.join('\n');
        const estimatedTime = this.calculateEstimatedTime();
        return {
            content,
            lineCount: this.lines.length,
            estimatedTime,
            filename: `${sheet.sheetCode}_cutting.nc`
        };
    }
    /**
     * Generate G-code for multiple sheets
     */
    generateForMultipleSheets(sheets) {
        return sheets.map(sheet => this.generateForSheet(sheet));
    }
    addHeader(sheet) {
        if (this.options.includeComments) {
            this.lines.push(`; ========================================`);
            this.lines.push(`; G-code generated by Nestra`);
            this.lines.push(`; Sheet: ${sheet.sheetCode}`);
            this.lines.push(`; Dimensions: ${sheet.sheetWidth} x ${sheet.sheetHeight} mm`);
            this.lines.push(`; Pieces: ${sheet.paths.length}`);
            this.lines.push(`; Date: ${new Date().toISOString()}`);
            this.lines.push(`; ========================================`);
            this.lines.push('');
        }
        // Program number (if supported)
        if (this.options.machineType === 'FANUC' || this.options.machineType === 'HAAS') {
            this.lines.push('O0001');
        }
    }
    addInitialization() {
        // Set units to mm
        this.lines.push('G21 ; Units: millimeters');
        // Absolute/relative positioning
        if (this.options.relativeCoords) {
            this.lines.push('G91 ; Relative positioning');
        }
        else {
            this.lines.push('G90 ; Absolute positioning');
        }
        // Select XY plane
        this.lines.push('G17 ; XY plane selection');
        // Cancel cutter compensation
        this.lines.push('G40 ; Cancel cutter compensation');
        // Move to safe position
        this.lines.push(`G0 Z${this.options.safeZ} ; Move to safe Z`);
        this.lines.push('G0 X0 Y0 ; Move to origin');
        // Start spindle
        this.lines.push(`M3 S${this.options.spindleSpeed} ; Spindle ON CW`);
        // Dwell for spindle to reach speed
        this.lines.push('G4 P2 ; Dwell 2 seconds');
        this.lines.push('');
    }
    addCuttingPath(path, index) {
        const { startX, startY, width, height } = path;
        const toolRadius = this.options.toolDiameter / 2;
        // Compensate for tool radius (outside cutting)
        const x1 = startX - toolRadius;
        const y1 = startY - toolRadius;
        const x2 = startX + width + toolRadius;
        const y2 = startY + height + toolRadius;
        if (this.options.includeComments) {
            this.lines.push(`; --- Piece ${index}: ${path.pieceCode ?? path.pieceId} ---`);
            this.lines.push(`; Dimensions: ${width} x ${height} mm`);
        }
        // Rapid move to start position (at safe Z)
        this.lines.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)} ; Rapid to start`);
        this.totalDistance += Math.sqrt(Math.pow(x1, 2) + Math.pow(y1, 2));
        // Plunge to cutting depth
        this.lines.push(`G0 Z${this.options.safeZ} ; Safe Z`);
        this.lines.push(`G1 Z${this.options.workZ} F${this.options.feedRate / 2} ; Plunge`);
        // Cut rectangle (clockwise)
        // Bottom edge (left to right)
        this.lines.push(`G1 X${x2.toFixed(3)} Y${y1.toFixed(3)} F${this.options.feedRate}`);
        this.totalDistance += width + this.options.toolDiameter;
        // Right edge (bottom to top)
        this.lines.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)}`);
        this.totalDistance += height + this.options.toolDiameter;
        // Top edge (right to left)
        this.lines.push(`G1 X${x1.toFixed(3)} Y${y2.toFixed(3)}`);
        this.totalDistance += width + this.options.toolDiameter;
        // Left edge (top to bottom, close path)
        this.lines.push(`G1 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);
        this.totalDistance += height + this.options.toolDiameter;
        // Retract to safe Z
        this.lines.push(`G0 Z${this.options.safeZ} ; Retract`);
        this.lines.push('');
    }
    addFooter() {
        // Stop spindle
        this.lines.push('M5 ; Spindle OFF');
        // Return to origin
        this.lines.push('G0 Z' + this.options.safeZ + ' ; Safe Z');
        this.lines.push('G0 X0 Y0 ; Return to origin');
        // Program end
        if (this.options.machineType === 'FANUC' || this.options.machineType === 'HAAS') {
            this.lines.push('M30 ; End program, rewind');
        }
        else {
            this.lines.push('M2 ; End program');
        }
        if (this.options.includeComments) {
            this.lines.push('');
            this.lines.push(`; Total cutting distance: ${this.totalDistance.toFixed(1)} mm`);
        }
    }
    calculateEstimatedTime() {
        // Rough estimate: cutting distance / feed rate + rapid moves
        const cuttingTime = this.totalDistance / this.options.feedRate;
        const rapidTime = this.totalDistance * 0.2 / this.options.rapidRate; // Estimate 20% rapid
        return cuttingTime + rapidTime;
    }
}
exports.GcodeGenerator = GcodeGenerator;
// ==================== HELPER FUNCTIONS ====================
/**
 * Generate G-code string for a sheet
 */
function generateGcode(sheet, options) {
    const generator = new GcodeGenerator(options);
    return generator.generateForSheet(sheet);
}
/**
 * Generate G-code for multiple sheets
 */
function generateMultipleGcode(sheets, options) {
    const generator = new GcodeGenerator(options);
    return generator.generateForMultipleSheets(sheets);
}
//# sourceMappingURL=gcode-generator.js.map